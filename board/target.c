/* Copyright (C) 2018 Daniel Page <csdsp@bristol.ac.uk>
 *
 * Use of this source code is restricted per the CC BY-NC-ND license, a copy of
 * which can be found via http://creativecommons.org (and should be included as
 * LICENSE.txt within the associated archive or repository).
 */

#include "target.h"

/** Read  an octet string (or sequence of bytes) from the UART, using a simple
  * length-prefixed, little-endian hexadecimal format.
  *
  * \param[out] r the destination octet string read
  * \return       the number of octets read
  */

int  octetstr_rd(       uint8_t* r, int n_r ) {
    char num[4];
    uint8_t in;
    int count = 0;
    while (1) {
      in = scale_uart_rd( SCALE_UART_MODE_BLOCKING);
      if (in == ':'){
        for (int j = 0; j < n_r; j++) {
          num[0] = scale_uart_rd( SCALE_UART_MODE_BLOCKING);
          num[1] = scale_uart_rd( SCALE_UART_MODE_BLOCKING);
          r[j] = strtol(num, NULL, 16);
          count += 2;
        }
        in = scale_uart_rd( SCALE_UART_MODE_BLOCKING);
        count++;
        if (in == '\n') return n_r;
        if (count > n_r) break;
      }
    }


    return n_r;
}


/** Write an octet string (or sequence of bytes) to   the UART, using a simple
  * length-prefixed, little-endian hexadecimal format.
  *
  * \param[in]  r the source      octet string written
  * \param[in]  n the number of octets written
  */
void octetstr_wr( const uint8_t* x, int n_x ) {
    char num[4];
    itoa(n_x, num, 16);  //sprintf is no avaliable in the scope
    if (strlen(num) == 1) {
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, '0' );
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[0]) );
    }
    else{
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[0]) );
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[1]) );
    }
    scale_uart_wr( SCALE_UART_MODE_BLOCKING, ':' );

    for (int i = 0; i < n_x; i++) {
      itoa(x[i], num, 16);

      if (strlen(num) == 1) {
        scale_uart_wr( SCALE_UART_MODE_BLOCKING, '0' );
        scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[0]) );
      }
      else{
        scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[0]) );
        scale_uart_wr( SCALE_UART_MODE_BLOCKING, toupper(num[1]) );
      }
    }
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, '\r' );
}

typedef uint8_t aes_gf28_t ;
uint8_t AES_RC[11] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36};
#define Nr 10
#define Nb 4
#define Nk 4

//s-box lookup table
const aes_gf28_t sbox[256] ={
  0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

//multiply 2 lookup table
const aes_gf28_t mul2[256]={
    0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
    0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
    0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
    0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
    0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
    0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
    0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
    0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
    0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
    0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
    0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
    0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
    0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
    0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
    0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
    0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
    };

//multiply 3 lookup table
const aes_gf28_t mul3[256]={
    0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
    0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
    0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
    0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
    0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
    0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
    0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
    0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
    0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
    0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
    0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
    0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
    0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
    0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
    0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
    0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
    };

aes_gf28_t sbox_masked[256];
uint8_t mask[5];
uint8_t mask_p[5];
aes_gf28_t rk_masked[11][16];

//sbox implementation
void aes_enc_exp_step( aes_gf28_t* r, const aes_gf28_t* rk, aes_gf28_t rc ){
    r[ 0 ] = rc ^ sbox [ rk[ 13 ] ] ^ rk[ 0 ];
    r[ 1 ] = sbox [ rk[ 14 ] ] ^ rk[ 1 ];
    r[ 2 ] = sbox [ rk[ 15 ] ] ^ rk[ 2 ];
    r[ 3 ] = sbox [ rk[ 12 ] ] ^ rk[ 3 ];

    r[ 4 ] = r[ 0 ] ^ rk[ 4 ];
    r[ 5 ] = r[ 1 ] ^ rk[ 5 ];
    r[ 6 ] = r[ 2 ] ^ rk[ 6 ];
    r[ 7 ] = r[ 3 ] ^ rk[ 7 ];

    r[ 8 ] = r[ 4 ] ^ rk[ 8 ];
    r[ 9 ] = r[ 5 ] ^ rk[ 9 ];
    r[ 10 ] = r[ 6 ] ^ rk[ 10 ];
    r[ 11 ] = r[ 7 ] ^ rk[ 11 ];

    r[ 12 ] = r[ 8 ] ^ rk[ 12 ];
    r[ 13 ] = r[ 9 ] ^ rk[ 13 ];
    r[ 14 ] = r[ 10 ] ^ rk[ 14 ];
    r[ 15 ] = r[ 11 ] ^ rk[ 15 ];
}

void aes_enc_rnd_key( aes_gf28_t* s, uint8_t round){
    for( int i = 0; i < 16; i++ ) {
        s[ i ] = s[ i ] ^ rk_masked[round][ i ];
    }
}

void aes_enc_rnd_sub( aes_gf28_t* s ){
    for( int i = 0; i < 16; i++ ) {
        s[ i ] = sbox_masked[ s[ i ] ];
    }
}

#define AES_ENC_RND_ROW_STEP(a,b,c,d,e,f,g,h) { \
    aes_gf28_t __a1 = s[ a ]; \
    aes_gf28_t __b1 = s[ b ]; \
    aes_gf28_t __c1 = s[ c ]; \
    aes_gf28_t __d1 = s[ d ]; \
    s[ e ] = __a1; \
    s[ f ] = __b1; \
    s[ g ] = __c1; \
    s[ h ] = __d1; \
}

void aes_enc_rnd_row ( aes_gf28_t * s ) {
    AES_ENC_RND_ROW_STEP ( 1, 5, 9, 13, 13, 1, 5, 9 );
    AES_ENC_RND_ROW_STEP ( 2, 6, 10, 14, 10, 14, 2, 6 );
    AES_ENC_RND_ROW_STEP ( 3, 7, 11, 15, 7, 11, 15, 3 );
}

#define AES_ENC_RND_MIX_STEP(a,b,c,d) { \
    aes_gf28_t __a1 = s[ a ]; \
    aes_gf28_t __b1 = s[ b ]; \
    aes_gf28_t __c1 = s[ c ]; \
    aes_gf28_t __d1 = s[ d ]; \
    s[ a ] = mul2[__a1] ^ mul3[__b1] ^       __c1 ^ __d1; \
    s[ b ] =       __a1 ^ mul2[__b1] ^ mul3[__c1] ^ __d1; \
    s[ c ] =       __a1 ^       __b1 ^ mul2[__c1] ^ mul3[__d1]; \
    s[ d ] = mul3[__a1] ^       __b1 ^       __c1 ^ mul2[__d1]; \
}

void aes_enc_rnd_mix ( aes_gf28_t * s ) {
    for( int i = 0; i < 4; i++, s += 4 ) {
        AES_ENC_RND_MIX_STEP( 0, 1, 2, 3 );
    }
}

void U8_TO_U8_N(aes_gf28_t* d, const uint8_t* s, int n){
    for (int i = 0; i < n; i++) {
        d[i] = s[i];
    }
}

void keyExpand(const uint8_t* k, const aes_gf28_t * rcp){
    U8_TO_U8_N( rk_masked[0] , k ,16);
    //expand 2nd - 11th subkeys
    for (int i = 0; i < Nr; i++) {
        aes_enc_exp_step(rk_masked[i + 1], rk_masked[i] , *(++rcp));
    }
}

void remasking(uint8_t* s, uint8_t m1, uint8_t m2, uint8_t m3, uint8_t m4, uint8_t m){
    //append masks on state matrix
	for(int i = 0; i < Nb; i++){
		s[0 + i * Nb] = s[0 + i * Nb] ^ (m1 ^ m);
		s[1 + i * Nb] = s[1 + i * Nb] ^ (m2 ^ m);
		s[2 + i * Nb] = s[2 + i * Nb] ^ (m3 ^ m);
		s[3 + i * Nb] = s[3 + i * Nb] ^ (m4 ^ m);
	}
}

void cal_MixColMask(){
    //Input column masks: m1, m2, m3, m4
    //Output column masks: m1’, m2’, m3’, m4’
	mask_p[0]	= mul2[mask[0]] ^ mul3[mask[1]] ^       mask[2] ^ mask[3];
	mask_p[1]	=	    mask[0] ^ mul2[mask[1]] ^ mul3[mask[2]] ^ mask[3];
	mask_p[2]	=       mask[0]	^       mask[1]	^ mul2[mask[2]]	^ mul3[mask[3]];
	mask_p[3]	= mul3[mask[0]]	^       mask[1] ^       mask[2] ^ mul2[mask[3]];
}

void cal_SboxMask(){
    //Sm(v ^ m) = S(v) ^ m’
    for(int i = 0; i < 256; i++){
		sbox_masked[i ^ mask[4]] = sbox[i] ^ mask_p[4];
	}
}

void updateMask(const uint8_t* r, uint8_t i){
    //update sbox mask m & m', this may lead big overheads
    mask[4] = r[i];
    mask_p[4] = r[i + 1];
    cal_SboxMask();
    //update mixCol mask, copy m0' m1' m2' m3' to m0 m1 m2 m3
    remasking(rk_masked[i], mask_p[0], mask_p[1], mask_p[2], mask_p[3], mask[4]);
    for (int j = 0; j < 4; j++) {
        mask[j] = mask_p[j];
    }
    cal_MixColMask();
}

/** Perform    an AES-128 encryption of a plaintext m under a cipher key k, to
  * yield the corresponding ciphertext c.
  *
  * \param[out] c   an   AES-128 ciphertext
  * \param[in]  m   an   AES-128 plaintext
  * \param[in]  k   an   AES-128 cipher key
  * \param[in]  r   some         randomness
  */

void aes_sbox( uint8_t* c, const uint8_t* m, const uint8_t* k , const uint8_t* r ) {
    aes_gf28_t s[ 4 * Nb ];
    U8_TO_U8_N( s, m , 16 );

    // 1 initial round
    remasking(s, mask_p[0], mask_p[1], mask_p[2], mask_p[3], 0);
    aes_enc_rnd_key ( s , 0 );

    // Nr - 1 iterated rounds
    for( int i = 1; i < Nr; i++ ) {
        aes_enc_rnd_sub ( s );
        aes_enc_rnd_row ( s );
        remasking(s, mask[0], mask[1], mask[2], mask[3], mask_p[4]);
        aes_enc_rnd_mix ( s );

        updateMask(r, i);
        aes_enc_rnd_key ( s , i );
    }
    // 1 final round
    aes_enc_rnd_sub ( s );
    aes_enc_rnd_row ( s );
    remasking(rk_masked[10], 0, 0, 0, 0, mask_p[4]);
    aes_enc_rnd_key ( s, 10 );

    U8_TO_U8_N ( c, s ,16 );

}
/** Initialise an AES-128 encryption, e.g., expand the cipher key k into round
  * keys, or perform randomised pre-computation in support of a countermeasure;
  * this can be left blank if no such initialisation is required, because the
  * same k and r will be passed as input to the encryption itself.
  *
  * \param[in]  k   an   AES-128 cipher key
  * \param[in]  r   some         randomness
  */

void aes_init( const uint8_t* k, const uint8_t* r ) {
    keyExpand(k, AES_RC);
    //intial 4 unique masks m0 m1 m2 m3
    mask[0] = r[0];
    for (int i = 1; i < 4; i++) {
        mask[i] = r[i];
        if (mask[i] == mask[i - 1]) mask[i]++;
    }
    cal_MixColMask();
    //inital sbox mask m & m'
    mask[4] = r[0];
    mask_p[4] = r[1];
	cal_SboxMask();
    remasking(rk_masked[0], mask_p[0], mask_p[1], mask_p[2], mask_p[3], mask[4]);
}

void print(const char* x, int n_x){
    for( int i = 0; i < n_x; i++ ) {
      scale_uart_wr( SCALE_UART_MODE_BLOCKING, x[ i ] );
    }
}

void check(){
    print("AES-128 with Mask Implementation Test\r", 38);
    print("-------------------------------------\r", 38);
    uint8_t c[ SIZEOF_BLK ];

    uint8_t c2[ 16 ] = { 0xEE, 0x73, 0xA8, 0x73, 0x02, 0xF6, 0x13, 0xFE,
                        0x44, 0xAF, 0xB8, 0x39, 0x09, 0xF6, 0x59, 0xAE };
    uint8_t k[ 16 ] = { 0xD3, 0x85, 0x33, 0x46, 0x02, 0x8B, 0x6E, 0x24,
                        0x86, 0x62, 0xE9, 0x95, 0xAB, 0x68, 0x7E, 0x25 };
    uint8_t m[ 16 ] = { 0xA7, 0xC6, 0xDD, 0xFC, 0xFA, 0xFA, 0x4B, 0xA8,
                        0xF9, 0x19, 0xA1, 0xB3, 0xB5, 0xDA, 0x1C, 0x2C };
    uint8_t r[ 16 ] = { 0xE6, 0x81, 0x49, 0x38, 0x66, 0x10, 0x14, 0xA1,
                        0x34, 0xE3, 0x22, 0x43, 0x7E, 0x00, 0x89, 0x31 };

    aes_init(       k, r );
    aes_sbox ( c, m, k, r );
    print("test k: ", 8);
    octetstr_wr( k, SIZEOF_BLK );
    print("test m: ", 8);
    octetstr_wr( m, SIZEOF_BLK );
    print("random: ", 8);
    octetstr_wr( r, SIZEOF_RND );
    print("test c: ", 8);
    octetstr_wr( c2, SIZEOF_BLK );
    print("calc c: ", 8);
    octetstr_wr( c, SIZEOF_BLK );
    print("-------------------------------------\r", 38);
    if( !memcmp( c, c2, 16 * sizeof( uint8_t ) ) ) {
        print("Result is correct\r", 18);
    }
    else {
        print("Result is wrong\r", 16);
    }
}
/** Initialise the SCALE development board, then loop indefinitely, reading a
  * command then processing it:
  *
  * 1. If command is inspect, then
  *
  *    - write the SIZEOF_BLK parameter,
  *      i.e., number of bytes in an  AES-128 plaintext  m, or ciphertext c,
  *      to the UART,
  *    - write the SIZEOF_KEY parameter,
  *      i.e., number of bytes in an  AES-128 cipher key k,
  *      to the UART,
  *    - write the SIZEOF_RND parameter,
  *      i.e., number of bytes in the         randomness r.
  *      to the UART.
  *
  * 2. If command is encrypt, then
  *
  *    - read  an   AES-128 plaintext  m from the UART,
  *    - read  some         randomness r from the UART,
  *    - initalise the encryption,
  *    - set the trigger signal to 1,
  *    - execute   the encryption, producing the ciphertext
  *
  *      c = AES-128.Enc( m, k )
  *
  *      using the hard-coded cipher key k plus randomness r if/when need be,
  *    - set the trigger signal to 0,
  *    - write an   AES-128 ciphertext c to   the UART.
  *
  * 3. If command is chech, then
  *
  *    - run the check() function to test the correctness of AES implementation.
  */

int main( int argc, char* argv[] ) {
  scale_conf_t scale_conf = {
    .clock_type        = SCALE_CLOCK_TYPE_EXT,
    .clock_freq_source = SCALE_CLOCK_FREQ_16MHZ,
    .clock_freq_target = SCALE_CLOCK_FREQ_16MHZ,

    .tsc               = false
  };

  if( !scale_init( &scale_conf ) ) {
    return -1;
  }

  uint8_t cmd[ 1 ], c[ SIZEOF_BLK ], r[ SIZEOF_RND ], m[ SIZEOF_BLK ];
  uint8_t k[ SIZEOF_KEY ] = { 0x54, 0x96, 0x5D, 0xAC, 0x02, 0xFE, 0x9B, 0xBB,
                              0x83, 0x43, 0xC9, 0x52, 0xE3, 0x1A, 0xC4, 0xD5 };


  while( true ) {
    if( 1 != octetstr_rd( cmd, 1 ) ) {
      break;
    }

    switch( cmd[ 0 ] ) {
      case COMMAND_INSPECT : {
        uint8_t t = SIZEOF_BLK;
                    octetstr_wr( &t, 1 );
                t = SIZEOF_KEY;
                    octetstr_wr( &t, 1 );
                t = SIZEOF_RND;
                    octetstr_wr( &t, 1 );

        break;
      }
      case COMMAND_ENCRYPT : {
              if( SIZEOF_BLK != octetstr_rd( m, SIZEOF_BLK ) ) {
                break;
              }
              if( SIZEOF_RND != octetstr_rd( r, SIZEOF_RND ) ) {
                break;
              }

              aes_init(       k, r );

              scale_gpio_wr( SCALE_GPIO_PIN_TRG,  true );
              aes_sbox ( c, m, k, r );
              scale_gpio_wr( SCALE_GPIO_PIN_TRG, false );

              octetstr_wr( c, SIZEOF_BLK );
        break;
      }
      case COMMAND_CHECK : check(); break;
      default : {
        break;
      }
    }
  }

  return 0;
}
